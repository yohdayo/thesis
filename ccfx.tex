\documentclass[11pt]{jarticle}
\usepackage{geometry}
\usepackage[dvipdfmx]{graphicx}
\usepackage{amsmath,amssymb,bm}


\title{定量的ソフトウェア開発管理\\第1回レポート}
\author{山崎瑶}
\date{2020年5月12日}

\begin{document}

\maketitle

\section{分析したプログラム}
本実験ではC言語で記述されたプログラムを用いている．大学構内に入れず手元に自作したC言語のプログラムがなかったため，友人の作成した2つのプログラムを分析した．

プログラム2はプログラム1を改良したものである．


\section{分析方法}
コードクローンの分析はCCFinderXを用いた．分析対象プログラミング言語はC言語なのでPreprocess Scriptはcppを選択し，Minimum Clone Lengthの値はデフォルトの50ではうまくコードクローンが検出されなかったため，20で設定した．P-matchは使用している．


\section{分析結果}
CCFinderXを実行し，得られた結果について述べる．
まず，検出されたコードクローンの例を以下に記載する．1つ目の例は両方のプログラムに存在する関数で，2つ目の例は与えられた行列を分割する関数であり行方向で分割する関数と列方向で分割する関数とでコードクローンとして検出された．

\begin{verbatim}
【別のファイルとの間のコードクローン】
void rand_matrix(int M, int N, double a[M][N])
{
  int i, j;

  for(i=0; i<M; i++){
    for(j=0; j<N; j++){
      a[i][j] = (double)rand()/RAND_MAX;
    }
  }
}

【ファイル内でのコードクローン】
void split_column_3(int M, int N, int N1, int N2, int N3, double a[M][N], double b[M][N1], double c[M][N2], double d[M][N3])
{
  int i, j;

  for(i=0; i<M; i++){
    for(j=0; j<N; j++){
      if(j<N1){
	b[i][j] = a[i][j];
      }else if(j>=N1 && j<N1+N2){
	c[i][j-N1] = a[i][j];
      }else{
	d[i][j-N1-N2] = a[i][j];
      }
    }
  }
}
\end{verbatim}

得られたファイルメトリクスを以下に記載する．

\begin{table}[htb]
\begin{center}
\caption{結果}
\begin{tabular}{|r||r|r|r|}
\hline
& Program1 & Program2 & Ave. \\
\hline \hline
LEN & 5722 & 7874 & 6798.0 \\
\hline
CLN & 32 & 42 & 37.0 \\
\hline
NBR & 1 & 1 & 1.0 \\
\hline
RSA & 0.579 & 0.453 & 0.506031 \\
\hline
RSI & 0.279 & 0.350 & 0.3198 \\
\hline
CVR & 0.654 & 0.607 & 0.62717 \\
\hline
RNR & 0.898 & 0.882 & 0.88857\\
\hline
\end{tabular}
\end{center}
\end{table}


\section{考察}
どのようなコードがコードクローンとして検出されたか調べ，コードクローンが発生した原因やそれを減らす方法，コードクローンが引き起こす問題について考える．

まず，プログラム2はプログラム1を改良したものであるので，2つのプログラムには共通の関数が多くある．その共通の関数の部分が別のファイルとの間のコードクローンとして検出された．文字列や変数名まで完全に同じであるため，これはタイプ1のクローンに当たる．関数を別ファイルに記入し，そのファイルから関数呼び出しを行うことにより改善できると考える．

実験結果のファイル内でのコードクローンの例のようにほとんど同じような機能の関数もコードクローンとして検出された．似た機能を持つコードはコピーして少し書き換えるだけで簡単に動くコードを書けて，機能しているコードは放置されやすいのでこのようなコードクローンが発生しやすいのだと考える．自分自身も大規模なコードを書くときはこういったコードクローンに注意を払おうと思った．

コードクローンが引き起こす問題として，コードの修正が困難になるという問題が挙げられる．本実験で比較したコードは改良版であるため，大きな問題にならないが，コードを修正する際，そのコードがコードクローンだとそれと対応するすべてのコードクローンも修正しなければならない場合がある．しかし，すべてのコードクローンを探し，修正するのは困難であり手間もかかる．そのため，コードクローンを作らないようにプログラムを書いたり，CCFinderXのようにコードクローンを見つけたり修正する技術の開発が大切である．ただ，現在の技術では検出できないタイプ3やタイプ4のようなコードクローンが存在したり，何らかの事情で必要だが似たような関数ができてしまった場合など，修正すべきコードクローンと修正すべきでないコードクローンとの区別をどのように行うか等の課題があると考える．

\end{document}